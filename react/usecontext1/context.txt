## 예제 프로젝트 기능

### 1. Theme Context
- 테마를 light/dark로 전환
- 여러 컴포넌트에서 테마 값 공유

### 2. Counter with Theme
- 테마에 따라 색상 변경
- Counter는 로컬 상태, 테마는 전역 상태

### 3. User Context
- 사용자 로그인/로그아웃
- 사용자 정보를 전역으로 관리

---

## useContext vs 다른 상태 관리

| 방법 | 사용 시기 | 복잡도 | 성능 |
|------|----------|--------|------|
| **useState** | 로컬 상태 | 낮음 | 빠름 |
| **useContext** | 몇 개 컴포넌트에 필요한 전역 상태 | 중간 | 중간 |
| **Redux** | 대규모 앱, 복잡한 상태 | 높음 | 빠름 |
| **Zustand** | 중간 규모 앱 | 낮음 | 빠름 |

### 언제 useContext를 사용해야 할까?

✅ **사용하면 좋은 경우**
- 사용자 인증 정보
- 테마 설정
- 언어 설정
- 알림 시스템
- 3-5단계 정도 깊이의 props drilling

❌ **다른 방법을 고려할 것**
- 매우 복잡한 상태 로직
- 성능이 중요한 대규모 앱
- 시간 여행 디버깅이 필요한 경우

---

## 주의사항

### 1. Provider 밖에서 사용하지 않기

```tsx
// ❌ 잘못된 사용
function App() {
  const { theme } = useTheme(); // 에러 발생!
  return <div>...</div>;
}

// ✅ 올바른 사용
function App() {
  return (
    <ThemeProvider>
      <SomeComponent /> {/* 여기서는 사용 가능 */}
    </ThemeProvider>
  );
}
```

### 2. Context 분리하기

```tsx
// ❌ 모든 것을 하나의 Context에
const AppContext = createContext({
  user: null,
  theme: 'light',
  language: 'ko',
  notifications: []
});

// ✅ 관련된 것끼리 분리
const UserContext = createContext(...);
const ThemeContext = createContext(...);
const LanguageContext = createContext(...);
```

### 3. 불필요한 리렌더링 방지

```tsx
// ⚠️ 주의: 전체 객체를 value로 전달하면 리렌더링 발생
<Context.Provider value={{ user, theme, language }}>

// ✅ useMemo 사용으로 방지
const value = useMemo(() => ({ user, theme, language }), [user, theme, language]);
<Context.Provider value={value}>
```

---

## 요약

1. **useContext**는 React의 전역 상태 관리 훅입니다
2. **Props Drilling** 문제를 해결합니다
3. **Context 생성 → Provider 설정 → useContext 사용**의 3단계로 사용
4. **Custom Hook**을 만들어 사용하면 더 안전하고 편리합니다
5. 복잡한 대규모 앱에는 Redux나 Zustand 등 다른 라이브러리를 고려하세요

---

## 추가 학습 자료

- [React 공식 문서 - useContext](https://react.dev/reference/react/useContext)
- [React 공식 문서 - Context API](https://react.dev/learn/passing-data-deeply-with-context)
- [TypeScript with React Hooks](https://react-typescript-cheatsheet.netlify.app/)

---
